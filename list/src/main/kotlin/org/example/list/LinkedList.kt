/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example.list

class LinkedList : List<String> {
    private var head: Node? = null

    /**
     * Appends the given string to the end of the list.
     *
     * If the list is empty the element becomes the new head; otherwise it is linked as the current tail's next node.
     *
     * @param element The string to append.
     */
    fun add(element: String) {
        val newNode = Node(element)

        val it = tail(head)
        if (it == null) {
            head = newNode
        } else {
            it.next = newNode
        }
    }

    /**
     * Returns the last node (tail) of the singly linked list starting from [head], or `null` if the list is empty.
     *
     * @param head the starting node of the list, or `null` for an empty list
     * @return the tail node or `null` when [head] is `null`
     */
    private fun tail(head: Node?): Node? {
        var it: Node?

        it = head
        while (it?.next != null) {
            it = it.next
        }

        return it
    }

    /**
     * Removes the first occurrence of the given element from the list.
     *
     * Searches from the head and unlinks the first node whose data equals the provided
     * element (case-sensitive). Only the first match is removed.
     *
     * @param element The string value to remove (case-sensitive).
     * @return True if a node was removed; false if no matching element was found.
     */
    fun remove(element: String): Boolean {
        var result = false
        var previousIt: Node? = null
        var it: Node? = head
        while (it != null) {
            if (0 == element.compareTo(it.data)) {
                result = true
                unlink(previousIt, it)
                break
            }
            previousIt = it
            it = it.next
        }

        return result
    }

    /**
     * Remove `currentIt` from the list by relinking its predecessor or updating `head`.
     *
     * If `currentIt` is the current head, `head` is set to `currentIt.next`; otherwise
     * `previousIt.next` is updated to skip `currentIt`.
     *
     * @param previousIt The node immediately before `currentIt`, or null when `currentIt` is the head.
     * @param currentIt The node to unlink from the list.
     */
    private fun unlink(
        previousIt: Node?,
        currentIt: Node,
    ) {
        if (currentIt == head) {
            head = currentIt.next
        } else {
            previousIt?.next = currentIt.next
        }
    }

    /**
     * Returns the number of elements in this linked list.
     *
     * @return The number of elements currently stored in the list.
     */
    override val size: Int
        get() {
            var size = 0
            var it = head
            while (it != null) {
                ++size
                it = it.next
            }
            return size
        }

    override fun isEmpty(): Boolean = head == null

    override fun contains(element: String): Boolean {
        var it = head
        while (it != null) {
            if (it.data == element) return true
            it = it.next
        }
        return false
    }

    override fun iterator(): Iterator<String> =
        object : Iterator<String> {
            private var current = head

            override fun hasNext() = current != null

            override fun next(): String {
                val data = current?.data ?: throw NoSuchElementException()
                current = current?.next
                return data
            }
        }

    override fun containsAll(elements: Collection<String>): Boolean {
        for (e in elements) {
            if (!contains(e)) return false
        }
        return true
    }

    /**
     * Returns the node at the specified 0-based index, or null if the index is negative or out of range.
     *
     * Traverses from the list head advancing `idx` steps. If `idx` is negative, or the list is shorter than
     * `idx + 1` elements, this function returns null.
     *
     * @param index 0-based position of the element to retrieve.
     * @return the string stored at the specified index.
     * @throws IndexOutOfBoundsException if no element exists at the requested index.
     */
    override fun get(index: Int): String {
        if (index < 0) throw IndexOutOfBoundsException("Index: $index")
        var index = index
        var it = head
        while (index > 0 && it != null) {
            it = it.next
            index--
        }
        if (it == null) throw IndexOutOfBoundsException("Index: $idx")
        return it.data
    }

    override fun indexOf(element: String): Int {
        var idx = 0
        var it = head
        while (it != null) {
            if (it.data == element) return idx
            it = it.next
            idx++
        }
        return -1
    }

    override fun lastIndexOf(element: String): Int {
        var idx = 0
        var lastIdx = -1
        var it = head
        while (it != null) {
            if (it.data == element) lastIdx = idx
            it = it.next
            idx++
        }
        return lastIdx
    }

    override fun listIterator(): ListIterator<String> {
        TODO("Not yet implemented")
    }

    override fun listIterator(index: Int): ListIterator<String> {
        TODO("Not yet implemented")
    }

    override fun subList(
        fromIndex: Int,
        toIndex: Int,
    ): List<String> {
        TODO("Not yet implemented")
    }

    private data class Node(
        val data: String,
    ) {
        var next: Node? = null
    }

    override val size: Int
        get() = calculateSize()

    /**
     * Returns true if this list contains the specified element.
     *
     * The comparison is case-sensitive and uses String equality.
     *
     * @param element element to search for
     * @return `true` if the element is present in the list, `false` otherwise
     */
    override fun contains(element: String): Boolean =
        throw UnsupportedOperationException("Not yet implemented")

    /**
     * Returns true if this list contains all elements in the specified collection.
     *
     * The check is performed using element equality (case-sensitive for strings). An empty
     * `elements` collection always returns `true`.
     *
     * @param elements Collection of strings to test for membership in this list.
     * @return `true` if every element in `elements` is contained in this list; `false` otherwise.
     */
    override fun containsAll(elements: Collection<String>): Boolean =
        throw UnsupportedOperationException("Not yet implemented")

    /**
     * Returns the element at the specified zero-based index.
     *
     * @param index The zero-based position of the element to retrieve.
     * @return The string stored at the given index.
     * @throws IndexOutOfBoundsException If the index is negative or not less than the list size.
     */
    override fun get(index: Int): String {
        val node = getNodeAt(index) ?: throw IndexOutOfBoundsException("Index: $index")
        return node.data
    }

    /**
     * Returns the index of the first occurrence of the specified element in this list, or -1 if the list does not contain the element.
     *
     * The search is case-sensitive and uses equality of strings. Currently not implemented.
     *
     * @throws UnsupportedOperationException Always thrown until this method is implemented.
     */
    override fun indexOf(element: String): Int =
        throw UnsupportedOperationException("Not yet implemented")

    /**
     * Returns true if the list contains no elements.
     *
     * @return `true` when the list is empty (i.e., `head == null`), otherwise `false`.
     */
    override fun isEmpty(): Boolean = head == null

    /**
     * Returns an iterator over the elements in this list.
     *
     * Currently not implemented; calling this function will always throw an exception.
     *
     * @return an Iterator over the list's elements
     * @throws UnsupportedOperationException always thrown by this implementation
     */
    override fun iterator(): Iterator<String> =
        throw UnsupportedOperationException("Not yet implemented")

    /**
     * Returns the index of the last occurrence of [element] in the list.
     *
     * Currently not implemented and will always throw [UnsupportedOperationException].
     *
     * Intended behavior when implemented: return the zero-based index of the last
     * element that is equal to [element] (case-sensitive). If the element is not
     * found, return -1.
     *
     * @param element The element to search for (case-sensitive).
     * @throws UnsupportedOperationException Always thrown until this method is implemented.
     */
    override fun lastIndexOf(element: String): Int =
        throw UnsupportedOperationException("Not yet implemented")

    /**
     * Returns a list iterator over the elements in this list, starting at the beginning.
     *
     * The returned iterator starts at index 0 and iterates over a snapshot of the list's elements.
     *
     * @return a ListIterator positioned before the first element.
     */
    override fun listIterator(): ListIterator<String> = listIterator(0)

    /**
     * Returns a ListIterator over a snapshot of the list starting at the given index.
     *
     * The iterator iterates over a stable copy of the list's elements taken at the time
     * of this call; subsequent modifications to the original list do not affect the iterator.
     *
     * @param index start position for the iterator (0..size)
     * @return a ListIterator<String> positioned at `index`
     * @throws IndexOutOfBoundsException if `index` is outside 0..size
     * @throws NoSuchElementException from `next()`/`previous()` when no element is available
     */
    override fun listIterator(index: Int): ListIterator<String> {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        val snapshot = this.toList()
        return object : ListIterator<String> {
            private var pos = index

            /**
             * Returns true if the iterator has more elements.
             *
             * @return true when the current position is before the end of the snapshot.
             */
            override fun hasNext(): Boolean = pos < snapshot.size

            /**
             * Returns the next element in the iterator and advances the position by one.
             *
             * @return the next `String` from the iterator snapshot.
             * @throws NoSuchElementException if there are no more elements (i.e., `hasNext()` is false).
             */
            override fun next(): String {
                if (!hasNext()) throw NoSuchElementException()
                return snapshot[pos++]
            }

            /**
             * Returns true if there is a previous element (i.e., the iterator is not at the start).
             *
             * @return true if a call to `previous()` would succeed.
             */
            override fun hasPrevious(): Boolean = pos > 0

            /**
             * Returns the previous element from the iterator's snapshot and moves the cursor one position toward the start.
             *
             * @return the previous element.
             * @throws NoSuchElementException if the iterator has no previous element.
             */
            override fun previous(): String {
                if (!hasPrevious()) throw NoSuchElementException()
                return snapshot[--pos]
            }

            /**
             * Returns the index of the element that would be returned by a subsequent `next()` call.
             *
             * For the snapshot-based list iterator this is the current cursor position (`pos`), in the range `0..size`.
             *
             * @return the next element's index (equal to the cursor position)
             */
            override fun nextIndex(): Int = pos

            /**
             * Returns the index of the element that would be returned by a subsequent call to `previous()`.
             *
             * @return the previous element's index, or -1 if the iterator is at the beginning of the list.
             */
            override fun previousIndex(): Int = pos - 1
        }
    }

    /**
     * Returns a new list containing the elements in the specified range [fromIndex, toIndex).
     *
     * The returned list is a snapshot (new ArrayList) of the elements from this linked list starting
     * at the zero-based index `fromIndex` (inclusive) up to `toIndex` (exclusive), preserving iteration order.
     *
     * @param fromIndex start index (inclusive), zero-based
     * @param toIndex end index (exclusive), zero-based
     * @return a new List<String> containing the requested range
     * @throws IndexOutOfBoundsException if fromIndex < 0, toIndex < fromIndex, or toIndex > size
     */
    override fun subList(
        fromIndex: Int,
        toIndex: Int,
    ): List<String> {
        if (fromIndex < 0 || toIndex < fromIndex || toIndex > size) {
            throw IndexOutOfBoundsException("fromIndex=$fromIndex, toIndex=$toIndex, size=$size")
        }
        val result = ArrayList<String>(toIndex - fromIndex)
        var i = 0
        var it = head
        while (i < toIndex && it != null) {
            if (i >= fromIndex) result.add(it.data)
            it = it.next
            i++
        }
        return result
    }
}
